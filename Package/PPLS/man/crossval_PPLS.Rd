% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crossval_PPLS.R
\name{crossval_PPLS}
\alias{crossval_PPLS}
\title{Cross-validate procedure for PPLS}
\usage{
crossval_PPLS(X, Y, a, nr_folds, nr_cores, ...)
}
\arguments{
\item{X}{Numeric matrix.}

\item{Y}{Numeric matrix.}

\item{a}{Vector of positive integers. Denotes the numbers of joint components to consider.}

\item{nr_folds}{Positive integer. Number of folds to consider. Note: \code{kcv=N} gives leave-one-out CV. Note that CV with less than two folds does not make sense.}

\item{nr_cores}{Positive integer. Number of cores to use for CV. You might want to use \code{\link{detectCores}()}. Defaults to 1.}

\item{...}{PPLS arguments}
}
\value{
List of class \code{"cvo2m"} with the original and sorted Prediction errors and the number of folds used.
}
\description{
Cross-validate procedure for PPLS
}
\details{
This is the standard CV approach. It minimizes the sum of the prediction errors of X and Y over a three-dimensional grid of integers.
Parallelization is possible on all platforms. On Windows it uses \code{\link{makePSOCKcluster}}, then exports all necessary objects to the workers,
 and then calls \code{\link{parLapply}}. On OSX and Linux the more friendly \code{\link{mclapply}} is used, which uses forking.
 A print method is defined, printing the minimizers and minimum in a readible way. Also the elapsed time is tracked and reported.
}
\examples{
local({
X = scale(jitter(tcrossprod(rnorm(100),runif(10))))
Y = scale(jitter(tcrossprod(rnorm(100),runif(10))))
crossval_PPLS(X, Y, a = 1:4,
             nr_folds = 5, nr_cores = 1, EMsteps = 1e3)
})

}
